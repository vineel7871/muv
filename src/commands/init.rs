use crate::InitArgs;
use anyhow::{Context, Result, bail};
use std::env;
use std::fs::{OpenOptions, read_to_string};
use std::io::Write;
use std::path::PathBuf;

const GUV_INIT_BLOCK_START: &str = "# GUV INIT START";
const GUV_INIT_BLOCK_END: &str = "# GUV INIT END";

fn get_shell_config_path() -> Result<(String, PathBuf)> {
    let shell_path = env::var("SHELL").unwrap_or_else(|_| "/bin/bash".to_string());
    let shell_name = PathBuf::from(&shell_path)
        .file_name()
        .and_then(|s| s.to_str())
        .unwrap_or("bash")
        .to_lowercase();

    let home_dir =
        dirs::home_dir().ok_or_else(|| anyhow::anyhow!("Could not find home directory"))?;

    match shell_name.as_str() {
        "bash" => Ok(("bash".to_string(), home_dir.join(".bashrc"))),
        "zsh" => Ok(("zsh".to_string(), home_dir.join(".zshrc"))),
        _ => bail!(
            "Unsupported shell: {}. GUV init currently supports bash and zsh.",
            shell_name
        ),
    }
}

fn generate_guv_function_content() -> Result<String> {
    let current_exe_path = env::current_exe()
        .context("Failed to get current executable path. Please ensure guv is in your PATH or provide the full path.")?;
    let guv_binary_path_str = current_exe_path
        .to_str()
        .ok_or_else(|| anyhow::anyhow!("Executable path is not valid UTF-8"))?;

    let escaped_guv_binary_path = guv_binary_path_str
        .replace('\\', "\\\\")
        .replace('"', "\\\"");

    Ok(format!(
        r#"# GUV shell functions
# This file contains shell functions for the guv tool

guv() {{
    local cmd="$1"
    local output
    local ret_code
    local guv_exe_path

    if [ -n "$GUV_BINARY_PATH" ] && [ -x "$GUV_BINARY_PATH" ]; then
        guv_exe_path="$GUV_BINARY_PATH"
    elif command -v guv >/dev/null 2>&1; then
        guv_exe_path="$(command -v guv)"
    else
        echo "Error: 'guv' executable not found." >&2
        echo "Please ensure GUV_BINARY_PATH is set correctly in your shell config," >&2
        echo "or that 'guv' is in your system PATH." >&2
        echo "You might need to run 'guv init' again or manually edit your shell config." >&2
        return 1
    fi

    case "$cmd" in
        activate)
            if [ -z "$2" ]; then
                echo "Usage: guv activate <environment_name>" >&2
                "$guv_exe_path" activate --help
                return 1
            fi
            shift
            output="$("$guv_exe_path" activate "$@" 2> >(tee /dev/stderr >&2))"
            ret_code=$?

            if [ $ret_code -eq 0 ] && [ -n "$output" ]; then
                // eval "$output"
                return $?
            elif [ $ret_code -ne 0 ]; then
                return $ret_code
            else
                echo "guv: activation command produced no output or an error occurred." >&2
                return 1
            fi
            ;;
        deactivate)
            if declare -f -F deactivate > /dev/null && [ -n "$GUV_ENV_NAME" ]; then
                 deactivate
                 return $?
            fi
            shift
            output="$("$guv_exe_path" deactivate "$@" 2> >(tee /dev/stderr >&2))"
            ret_code=$?
            if [ $ret_code -eq 0 ] && [ -n "$output" ]; then
                eval "$output"
                return $?
            elif [ $ret_code -ne 0 ]; then
                return $ret_code
            else
                echo "guv: deactivation command produced no output or an error occurred." >&2
                return 1
            fi
            ;;
        *)
            "$guv_exe_path" "$@"
            return $?
            ;;
    esac
}}"#
    ))
}

fn generate_shell_script_content() -> Result<String> {
    let current_exe_path = env::current_exe()
        .context("Failed to get current executable path. Please ensure guv is in your PATH or provide the full path.")?;
    let guv_binary_path_str = current_exe_path
        .to_str()
        .ok_or_else(|| anyhow::anyhow!("Executable path is not valid UTF-8"))?;

    let escaped_guv_binary_path = guv_binary_path_str
        .replace('\\', "\\\\")
        .replace('"', "\\\"");

    Ok(format!(
        r#"
{GUV_INIT_BLOCK_START}
# This block was auto-generated by 'guv init'.
# To re-generate, run 'guv init --force'.

# Set this to the path of your guv binary if it's not in your PATH
export GUV_BINARY_PATH="{escaped_guv_binary_path}"

# Source the guv functions from separate file
[ -f "$HOME/.guv-functions.sh" ] && source "$HOME/.guv-functions.sh"
{GUV_INIT_BLOCK_END}
"#
    ))
}

fn is_guv_initialized(config_content: &str) -> bool {
    config_content.contains(GUV_INIT_BLOCK_START) && config_content.contains(GUV_INIT_BLOCK_END)
}

fn remove_existing_guv_block(content: &str) -> String {
    let mut new_content = String::new();
    let mut in_guv_block = false;
    for line in content.lines() {
        if line.trim() == GUV_INIT_BLOCK_START {
            in_guv_block = true;
            continue;
        }
        if line.trim() == GUV_INIT_BLOCK_END {
            in_guv_block = false;
            continue;
        }
        if !in_guv_block {
            new_content.push_str(line);
            new_content.push('\n');
        }
    }
    if !content.ends_with('\n') && new_content.ends_with('\n') {
        new_content.pop();
    }
    new_content
}

pub fn handle_init(args: InitArgs) -> Result<()> {
    let (shell_name, config_path) = get_shell_config_path()?;
    let home_dir =
        dirs::home_dir().ok_or_else(|| anyhow::anyhow!("Could not find home directory"))?;
    let functions_path = home_dir.join(".guv-functions.sh");

    println!(
        "Detected shell: {} (config file: {})",
        shell_name,
        config_path.display()
    );

    let mut config_content = if config_path.exists() {
        read_to_string(&config_path).with_context(|| {
            format!(
                "Failed to read shell config file: {}",
                config_path.display()
            )
        })?
    } else {
        println!(
            "Shell config file {} does not exist. It will be created.",
            config_path.display()
        );
        String::new()
    };

    if is_guv_initialized(&config_content) {
        if args.force {
            println!("GUV seems to be already initialized. --force specified, re-initializing...");
            config_content = remove_existing_guv_block(&config_content);
        } else {
            println!(
                "GUV seems to be already initialized in {}.",
                config_path.display()
            );
            println!("To re-initialize, run 'guv init --force'.");
            println!("To apply changes, please source your shell config or open a new terminal:");
            println!("  source {}", config_path.display());
            return Ok(());
        }
    }

    let functions_content = generate_guv_function_content()?;
    let mut functions_file = OpenOptions::new()
        .write(true)
        .create(true)
        .truncate(true)
        .open(&functions_path)
        .with_context(|| {
            format!(
                "Failed to create functions file: {}",
                functions_path.display()
            )
        })?;

    functions_file
        .write_all(functions_content.as_bytes())
        .with_context(|| format!("Failed to write to {}", functions_path.display()))?;

    let script_to_add = generate_shell_script_content()?;

    if !config_content.is_empty() && !config_content.ends_with('\n') {
        config_content.push('\n');
    }
    config_content.push_str(&script_to_add);
    if !config_content.ends_with('\n') {
        config_content.push('\n');
    }

    let mut file = OpenOptions::new()
        .write(true)
        .create(true)
        .truncate(true)
        .open(&config_path)
        .with_context(|| format!("Failed to open {} for writing", config_path.display()))?;

    file.write_all(config_content.as_bytes())
        .with_context(|| format!("Failed to write to {}", config_path.display()))?;

    println!(
        "\nGUV initialization script added to {}.",
        config_path.display()
    );
    println!("GUV functions written to {}.", functions_path.display());
    println!("Please source your shell config file or open a new terminal to apply changes:");
    println!("  source {}", config_path.display());
    println!("\nAfter that, you can use 'guv activate <env>' and 'guv deactivate' directly.");

    Ok(())
}
