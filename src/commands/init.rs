// src/commands/init.rs
use crate::InitArgs; // Make sure InitArgs is pub in main.rs
use anyhow::{Result, bail, Context};
use std::env;
use std::fs::{OpenOptions, read_to_string};
use std::io::{Write};
use std::path::PathBuf;

const GUV_INIT_BLOCK_START: &str = "# GUV INIT START";
const GUV_INIT_BLOCK_END: &str = "# GUV INIT END";

fn get_shell_config_path() -> Result<(String, PathBuf)> {
    let shell_path = env::var("SHELL").unwrap_or_else(|_| "/bin/bash".to_string()); // Default to bash
    let shell_name = PathBuf::from(&shell_path)
        .file_name()
        .and_then(|s| s.to_str())
        .unwrap_or("bash")
        .to_lowercase();

    let home_dir = dirs::home_dir().ok_or_else(|| anyhow::anyhow!("Could not find home directory"))?;

    match shell_name.as_str() {
        "bash" => Ok(("bash".to_string(), home_dir.join(".bashrc"))),
        "zsh" => Ok(("zsh".to_string(), home_dir.join(".zshrc"))),
        // Add other shells here if needed (e.g., fish)
        _ => bail!(
            "Unsupported shell: {}. GUV init currently supports bash and zsh.",
            shell_name
        ),
    }
}

fn generate_shell_script_content() -> Result<String> {
    let current_exe_path = env::current_exe()
        .context("Failed to get current executable path. Please ensure guv is in your PATH or provide the full path.")?;
    let guv_binary_path_str = current_exe_path.to_str().ok_or_else(|| anyhow::anyhow!("Executable path is not valid UTF-8"))?;

    // Escape backslashes and double quotes for the shell string
    let escaped_guv_binary_path = guv_binary_path_str.replace('\\', "\\\\").replace('"', "\\\"");


    Ok(format!(
        r#"
{GUV_INIT_BLOCK_START}
# This block was auto-generated by 'guv init'.
# To re-generate, run 'guv init --force'.

# Set this to the path of your guv binary if it's not in your PATH
# or if you want to be explicit.
# The init script attempts to set this automatically.
export GUV_BINARY_PATH="{escaped_guv_binary_path}"

guv() {{
    local cmd="$1"
    local output
    local ret_code
    local guv_exe_path

    # Determine the guv executable to use
    if [ -n "$GUV_BINARY_PATH" ] && [ -x "$GUV_BINARY_PATH" ]; then
        guv_exe_path="$GUV_BINARY_PATH"
    elif command -v guv >/dev/null 2>&1; then
        # If guv command is in PATH and GUV_BINARY_PATH is not set or invalid, use the one in PATH
        # This is useful if the user installed guv via cargo install to a PATH directory
        guv_exe_path="$(command -v guv)"
    else
        echo "Error: 'guv' executable not found." >&2
        echo "Please ensure GUV_BINARY_PATH is set correctly in your shell config," >&2
        echo "or that 'guv' is in your system PATH." >&2
        echo "You might need to run 'guv init' again or manually edit your shell config." >&2
        return 1
    fi

    case "$cmd" in
        activate)
            if [ -z "$2" ]; then
                echo "Usage: guv activate <environment_name>" >&2
                "$guv_exe_path" activate --help # Show help from the binary
                return 1
            fi
            shift # remove "activate"
            # Capture stdout for eval, stderr will pass through
            # Use process substitution for robust error code handling if shell supports it
            # For simpler POSIX compliance, direct variable assignment is used.
            output="$("$guv_exe_path" activate "$@" 2> >(tee /dev/stderr >&2))"
            ret_code=$?

            if [ $ret_code -eq 0 ] && [ -n "$output" ]; then
                eval "$output"
                return $? # Return status of eval
            elif [ $ret_code -ne 0 ]; then
                # Error message should have been printed to stderr by the binary or tee
                return $ret_code
            else
                # This case might happen if activate prints nothing on success (unlikely with current setup)
                # Or if stderr redirection fails silently
                echo "guv: activation command produced no output or an error occurred." >&2
                return 1
            fi
            ;;
        deactivate)
            # If 'deactivate' shell function is defined by our activate, use it preferentially
            if declare -f -F deactivate > /dev/null && [ -n "$GUV_ENV_NAME" ]; then
                 deactivate # Call the shell function 'deactivate'
                 return $?
            fi
            # Fallback to calling guv-binary deactivate
            shift # remove "deactivate"
            output="$("$guv_exe_path" deactivate "$@" 2> >(tee /dev/stderr >&2))"
            ret_code=$?
            if [ $ret_code -eq 0 ] && [ -n "$output" ]; then
                eval "$output"
                return $? # Return status of eval
            elif [ $ret_code -ne 0 ]; then
                return $ret_code
            else
                echo "guv: deactivation command produced no output or an error occurred." >&2
                return 1
            fi
            ;;
        *)
            # For all other commands, just pass them through to the binary
            "$guv_exe_path" "$@"
            return $?
            ;;
    esac
}}
{GUV_INIT_BLOCK_END}
"#
    ))
}

fn is_guv_initialized(config_content: &str) -> bool {
    config_content.contains(GUV_INIT_BLOCK_START) && config_content.contains(GUV_INIT_BLOCK_END)
}

fn remove_existing_guv_block(content: &str) -> String {
    let mut new_content = String::new();
    let mut in_guv_block = false;
    for line in content.lines() {
        if line.trim() == GUV_INIT_BLOCK_START {
            in_guv_block = true;
            continue;
        }
        if line.trim() == GUV_INIT_BLOCK_END {
            in_guv_block = false;
            continue;
        }
        if !in_guv_block {
            new_content.push_str(line);
            new_content.push('\n');
        }
    }
    // Remove trailing newline if original didn't have one and new_content is not empty
    if !content.ends_with('\n') && new_content.ends_with('\n') {
        new_content.pop();
    }
    new_content
}


pub fn handle_init(args: InitArgs) -> Result<()> {
    let (shell_name, config_path) = get_shell_config_path()?;

    println!(
        "Detected shell: {} (config file: {})",
        shell_name,
        config_path.display()
    );

    let mut config_content = if config_path.exists() {
        read_to_string(&config_path)
            .with_context(|| format!("Failed to read shell config file: {}", config_path.display()))?
    } else {
        println!("Shell config file {} does not exist. It will be created.", config_path.display());
        String::new()
    };

    if is_guv_initialized(&config_content) {
        if args.force {
            println!("GUV seems to be already initialized. --force specified, re-initializing...");
            config_content = remove_existing_guv_block(&config_content);
        } else {
            println!("GUV seems to be already initialized in {}.", config_path.display());
            println!("To re-initialize, run 'guv init --force'.");
            println!("To apply changes, please source your shell config or open a new terminal:");
            println!("  source {}", config_path.display());
            return Ok(());
        }
    }

    let script_to_add = generate_shell_script_content()?;

    // Ensure there's a newline before appending if content is not empty and doesn't end with one
    if !config_content.is_empty() && !config_content.ends_with('\n') {
        config_content.push('\n');
    }
    config_content.push_str(&script_to_add);
    // Ensure the file ends with a newline
    if !config_content.ends_with('\n') {
        config_content.push('\n');
    }


    let mut file = OpenOptions::new()
        .write(true)
        .create(true)
        .truncate(true) // Overwrite the entire file with modified content
        .open(&config_path)
        .with_context(|| format!("Failed to open {} for writing", config_path.display()))?;

    file.write_all(config_content.as_bytes())
        .with_context(|| format!("Failed to write to {}", config_path.display()))?;

    println!("\nGUV initialization script added to {}.", config_path.display());
    println!("Please source your shell config file or open a new terminal to apply changes:");
    println!("  source {}", config_path.display());
    println!("\nAfter that, you can use 'guv activate <env>' and 'guv deactivate' directly.");

    Ok(())
}